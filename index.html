<html lang="en-GB">

<head>
    <meta charset="utf-8" />
    <title>Abstractus</title>
</head>

<body>
    <p>
        <input type="file" id="source-selector" accept=".png" onchange="onSourceChanged();">
        <button onclick="onSourceChanged();">Resubmit</button>
    </p>
    <hr />
    <p>
        <h3>Rotation correction <button id="show-rotation-toggle" onclick="onToggleShowRotation();">Show</button></h3>
    </p>
    <div id="rotation-iterations" style="display:none"></div>
    <hr />
    <p>
        <h3>Grid line removal <button id="show-degrid-toggle" onclick="onToggleShowDegrid();">Show</button></h3>
    </p>
    <div id="degrid" style="display:none"></div>
</body>

<script src="rotation.js"></script>
<script src="degrid.js"></script>
<script>

    const sourceSelector = document.getElementById("source-selector");

    const showRotationToggle = document.getElementById("show-rotation-toggle");
    const rotationIterationsDiv = document.getElementById("rotation-iterations");
    const showDegridToggle = document.getElementById("show-degrid-toggle");
    const degridDiv = document.getElementById("degrid");

    // Working variables below are declared in order of computation

    const CANVAS = {
        ORIGINAL: 0,
        ROTATED: 1,
        BW: 2,
        DEGRIDDED: 3
    }
    const nCanvases = 4;
    let canvases;
    let contexts;
    let w; let h; // width and height of image
    let l = 0; let r = 0; let t = 0; let b = 0; // bounds of *chart area*
    let w2; let wh; // width and height of chart area

    // Note: bwBitmap is sporadically updated through the process, at different times from the canvasses
    // a uint8array is easier to read from, but a canvas is more efficient to write en masse to. e.g.
    // when stripping grid lines we read from bwBitmap but strip from the BW canvas.
    let bwBitmap;

    let freqResults = {
        xData: null,
        yData: null,
        xMax: 0,
        yMax: 0
    }

    function onSourceChanged() {

        while (rotationIterationsDiv.lastElementChild)
            rotationIterationsDiv.removeChild(rotationIterationsDiv.lastElementChild);
        rotationIterationsDiv.innerText = "";

        while (degridDiv.lastElementChild)
            degridDiv.removeChild(degridDiv.lastElementChild);
        degridDiv.innerText = "";

        if (sourceSelector.files.length == 0)
            return;

        const promise = createImageBitmap(sourceSelector.files[0]);
        promise.then(processBitmap, (reason) => alert("Image could not be loaded:" + reason));

    }

    function onToggleShowRotation() {
        if (showRotationToggle.innerText == "Show") {
            rotationIterationsDiv.style.display = "block";
            showRotationToggle.innerText = "Hide";
        } else {
            rotationIterationsDiv.style.display = "none";
            showRotationToggle.innerText = "Show";
        }
    }

    function onToggleShowDegrid() {
        if (showDegridToggle.innerText == "Show") {
            degridDiv.style.display = "block";
            showDegridToggle.innerText = "Hide";
        } else {
            degridDiv.style.display = "none";
            showDegridToggle.innerText = "Show";
        }
    }

    function processBitmap(bitmap) {

        w = bitmap.width;
        h = bitmap.height;

        canvases = [];
        contexts = [];
        for (let i = 0; i < nCanvases; i++) {
            canvases.push(document.createElement("canvas"));
            canvases[i].width = w; canvases[i].height = h;
            contexts.push(canvases[i].getContext("2d"));
        }

        bwBitmap = new Uint8ClampedArray(w * h * 4);
        freqResults.xData = new Uint16Array(w);
        freqResults.yData = new Uint16Array(h);
        freqResults.x = 0;
        freqResults.y = 0;

        contexts[CANVAS.ORIGINAL].drawImage(bitmap, 0, 0);
        bitmap.close();

        // Begin recomputation cascade
        recomputeRotation();

    }


</script>

</html>