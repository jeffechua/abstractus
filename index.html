<html lang="en-GB">

<head>
    <meta charset="utf-8" />
    <title>Abstractus</title>
</head>

<body>
    <p>
        <input type="file" id="source-selector" accept=".png" onchange="onSourceChanged();">
        <button onclick="onSourceChanged();">Resubmit</button>
    </p>
    <hr />
    <p>
        <h3>Rotation correction <button id="rotation-toggle" onclick="toggleSection(SECTION.ROTATION);">Show</button>
        </h3>
    </p>
    <div id="rotation-div" style="display:none"></div>
    <hr />
    <p>
        <h3>Bwify <button id="bwify-toggle" onclick="toggleSection(SECTION.BWIFY);">Show</button>
            <table>
                <tr>
                    <td>Cutoff:</td>
                    <td><input type="number" min="0.0" max="1.0" step="0.02" id="bwify-thresh-number" style="width:50px"
                            onchange="setBwifyIntensityThreshold(this.value);"></td>
                    <td><input type="range" min="0.0" max="1.0" step="0.02" class="slider" id="bwify-thresh-slider"
                            onchange="setBwifyIntensityThreshold(this.value);"></td>
                    <td><button
                            onclick="setBwifyIntensityThreshold(defaultBwifyParams.intensityThreshold)">Reset</button>
                    </td>
                </tr>
            </table>
        </h3>
    </p>
    <div id="bwify-div" style="display:none">
        <canvas id="bwify-canvas"></canvas>
    </div>
    <hr />
    <p>
        <h3>Degridding <button id="degrid-toggle" onclick="toggleSection(SECTION.DEGRID);">Show</button>
            <table>
                <tr>
                    <td><a
                            title="When the frequency (in % of max registered frequency) exceeds this value, a grid line is registered.">Detection
                            threshold</a> (%):</td>
                    <td><input type="number" min="0" max="100" id="degrid-detection-number" style="width:50px"
                            onchange="setDegridDetectionThreshold(this.value);"></td>
                    <td><input type="range" min="0" max="100" class="slider" id="degrid-detection-slider"
                            onchange="setDegridDetectionThreshold(this.value);"></td>
                    <td><button
                            onclick="setDegridDetectionThreshold(defaultDegridParams.detectionThreshold*100);">Reset</button>
                    </td>
                </tr>
                <tr>
                    <td><a
                            title="After a grid line is registered, its registered span is extended in both directions until the rate of decrease of the frequency graph (in % of max registered frequency / pixel) goes below this threshold.">Slope
                            threshold</a> (%/px):</td>
                    <td><input type="number" min="0" max="100" id="degrid-slope-number" style="width:50px"
                            onchange="setDegridSlopeThreshold(this.value);"></td>
                    <td><input type="range" min="0" max="100" class="slider" id="degrid-slope-slider"
                            onchange="setDegridSlopeThreshold(this.value);"></td>
                    <td><button
                            onclick="setDegridSlopeThreshold(defaultDegridParams.slopeThreshold*100);">Reset</button>
                    </td>
                </tr>
                <tr>
                    <td><a
                            title="After a grid line's span is resolved as per the slope threshold, a further margin of this number of pixels is added to the front and back (unless specifically set otherwise in the advanced interface below).">Default
                            margin</a> (px):</td>
                    <td><input type="number" min="0" max="100" id="degrid-defmargin-number" style="width:50px"
                            onchange="setDegridDefaultMargin(this.value);"></td>
                    <td></td>
                    <td><button onclick="setDegridDefaultMargin(defaultDegridParams.defaultMargin);">Reset</button>
                    </td>
                </tr>
            </table>
        </h3>
    </p>
    <div id="degrid-div" style="display:none"></div>
    <hr />
    <p>
        <h3>Clean <button id="clean-toggle" onclick="toggleSection(SECTION.CLEAN);">Show</button></h3>
        <div id="clean-div" style="display:block"></div>
    </p>
</body>

<script src="rotation.js"></script>
<script src="bwify.js"></script>
<script src="degrid.js"></script>
<script src="clean.js"></script>
<script>

    const sourceSelector = document.getElementById("source-selector");

    // UI stuff

    const SECTION = {
        ROTATION: 0,
        BWIFY: 1,
        DEGRID: 2,
        CLEAN: 3
    }
    const sectionNames = [
        "rotation",
        "bwify",
        "degrid",
        "clean"
    ]
    const sectionToggles = [];
    const sectionDivs = [];
    for (let i = 0; i < sectionNames.length; i++) {
        sectionToggles.push(document.getElementById(sectionNames[i] + "-toggle"));
        sectionDivs.push(document.getElementById(sectionNames[i] + "-div"));
    }

    function toggleSection(i) {
        if (sectionToggles[i].innerText == "Show") {
            sectionDivs[i].style.display = "block";
            sectionToggles[i].innerText = "Hide";
        } else {
            sectionDivs[i].style.display = "none";
            sectionToggles[i].innerText = "Show";
        }
    }

    function clearSection(i) {
        while (sectionDivs[i].lastElementChild)
            sectionDivs[i].removeChild(sectionDivs[i].lastElementChild);
        sectionDivs[i].innerText = "";
    }

    // Processing stuff

    const CANVAS = {
        ORIGINAL: 0,
        ROTATED: 1,
        BW: 2,
        DEGRIDDED: 3,
        POSTCROP: 4,
        POSTCLEAN: 5,
        FINAL: 6
    }
    let canvases; // array over CANVAS.
    let contexts;

    let w; let h; // width and height of image
    let w2; let wh; // width and height of chart area
    let l = 0; let r = 0; let t = 0; let b = 0; // bounds of *chart area*

    let rotatedBitmap; // bitmap data of canvases[CANVAS.ROTATED]
    let bwBitmap;      // bitmap data of canvases[CANVAS.BW]

    let progress = -1;

    function onSourceChanged() {

        if (sourceSelector.files.length == 0)
            return;

        const promise = createImageBitmap(sourceSelector.files[0]);
        promise.then(processBitmap, (reason) => alert("Image could not be loaded:" + reason));

    }

    function processBitmap(bitmap) {

        w = bitmap.width;
        h = bitmap.height;

        canvases = [];
        contexts = [];
        for (let i = 0; i < CANVAS.POSTCROP; i++) {
            canvases.push(document.createElement("canvas"));
            canvases[i].width = w; canvases[i].height = h;
            contexts.push(canvases[i].getContext("2d"));
        }

        contexts[CANVAS.ORIGINAL].drawImage(bitmap, 0, 0);
        bitmap.close();

        // Begin recomputation cascade
        recomputeRotation();

    }

    function parseLength(text) {
        return parseInt(text.substr(0, text.length - 2));
    }

    // anchor: -1 = left, 0 = center, 1 = right
    // radius is half the width given for the element to center itself in for the centering trick.
    function putAtAbsolutePosition(element, container, x, y, xAnchor, yAnchor, z = -1, radius = 100) {

        container.appendChild(element);
        element.style.position = "absolute";

        switch (xAnchor) {
            case -1:
                element.style.left = x + "px";
                break;
            case 0:
                element.style.left = (x - radius) + "px";
                element.style.right = (parseLength(container.style.width) - (x + radius)) + "px";
                element.style.marginLeft = "auto";
                element.style.marginRight = "auto";
                break;
            case 1:
                element.style.right = x + "px";
        }

        switch (yAnchor) {
            case -1:
                element.style.top = y + "px";
                break;
            case 0:
                element.style.top = (y - radius) + "px";
                element.style.bottom = (parseLength(container.style.height) - (y + radius)) + "px";
                element.style.marginTop = "auto";
                element.style.marginBottom = "auto";
                break;
            case 1:
                element.style.bottom = y + "px";
        }

        if (z != -1)
            element.style.zIndex = z;
    }

</script>

</html>